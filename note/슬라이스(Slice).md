## 슬라이스

Go 배열은 고정된 배열크기 안에 동일한 타입의 데이터를 연속적으로 저장하지만, 배열의 크기를
동적으로 증가시키거나 부분 배열을 발췌하는 등의 기능을 가지고 있지 않다. Go Slice는 
내부적으로 배열에 기초하여 만들어 졌지만 배열의 이런 제약점들을 넘어 개발자에게 편리하고 
유용한 기능들을 제공한다.

슬라이스는 배열과 달리 고정된 크기를 미리 지정하지 않을 수 있고, 차후 그 크기를 동적으로 변경할
수도 있고, 또한 부분 배열을 발췌할 수도 있다. 

Go Slice 선언은 배열을 선언하듯이 var v []T 처럼 하는데 배열과 달리 크기는 지정하지 않는다. 

```go

package main

import (
    "fmt"
)

func main() {
    var a []int
    a = []int{1, 2, 3}
    fmt.Println(a[1])
}
```

Go에서 Slice를 생성하는 또 다른 방법으로 Go의 내장함수 make() 함수를 이용할 수 있다. 
make() 함수로 슬라이스를 생성하면, 개발자가 슬라이스의 길이 (Length)와 용량을 임의로 
지정할 수 있는 장점이 있다. 

make()  함수의 첫번째 파라미터에 생성할 슬라이스 타입을 지정하고, 두번째는 Length , 그리고 
세번째는 Capacity를 지정하면, 모든 요소가 Zero value인 슬라이스를 만들게 된다. 

여기서 만약 세번째 capacity를 생략하면 Capacity는 Length 와 같은 값을 갖는다. 

```go

package main

import (
    "fmt"
)

func main() {
    a := make([]int, 2)
    b := make([]int, 2, 4)
    fmt.Println(a[0])
    fmt.Println(b[0])
}
```

슬라이스에 별도의 길이와 용량을 지정하지 않으면 기본적으로 길이와 용량이 0인 슬라이스를 만드는데, 
이를 Nil Slice라고 하고, nil 과 비교하면 참을 리턴한다. 

```go

package main

import (
    "fmt"
)

func main() {
    var a []int
    if a == nil {
        fmt.Println("Nil Slice")
    }
}
```

부분 슬라이스 (Sub-slice)

슬라이스에서 일부를 발췌하여 부분 슬라이스를 만들 수 있다. 부분 슬라이스는 
"슬라이스[처음인덱스 : 마지막 인덱스]" 형식으로 만드는데, 예를 들어 슬라이스 s 에 대해 
인덱스 2부터 4까지 데이터를 갖는 부분 슬라이스를 만들려면, s[2:5]와 같이 표현한다. 
마지막인덱스는 원하는 인덱스 +1 을 한다. 

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1, 2, 3, 4, 5}
    s = s[2:5]
    fmt.Println(s[2])
}
```

슬라이스 인덱슨느 처음/마지막 둘 중 하나 혹은 둘 다를 생략할 수도 있다. 
처음 인덱스가 생략되면 0이, 마지막 인덱스가 생략되면 그 슬라이스의 마지막 인덱스가 자동 
대입된다. 즉, 처음 0부터 인덱스 4까지를 포함하기 위해서는 [:5]를, 인덱스 2부터 마지막까지 포함하기
위해서는 [2:]와 같이 쓸 수 있다. 만약 [:]와 같이 모두 생략하면 전체를 표현한다. 

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1, 2, 3, 4, 5}
    s = s[2:]
    fmt.Println(s[2])
}
```

슬라이스 추가, 병합(append)와 복사(copy)   

슬라이스에 새로운 요소를 추가하려면 Go의 내장함수 append()를 사용한다.

append() 함수는 두 개의 파라미터를 받는데, 첫번째 파라미터는 추가할 슬라이스이고, 두번째 파라미터는
추가할 요소이다.

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1}
    s = append(s, 2)
    fmt.Println(s[2])
}
```
내장함수 append() 가 슬라이스에 데이터를 추가할 때, 내부적으로 다음과 같은 일이 일어난다. 슬라이스
용량이 아직 남아있는경우는 그 용량 내에서 슬라이스의 길이를 변경하여 데이터를 추가하고 
용량을 초과하는 경우 현재 용량의 2배에 해당하는 새로운 Underlyting array를 생성하고
기존 배열 값들을 모두 새 배열에 복제한 후 다시 슬라이스를 할당한다.

아래 예제는 길이 0 용량 3의 슬라이스에 1 부터 15까지의 숫자를 계속 추가하면서 슬라이스의 
길이와 용량이 어떻게 변하는지를 체크하는 코드이다. 이 코드를 실행하면 1~3까지는 기존의 
용량 3을 사용하고, 4~6까지는 용량 6을 

```go

package main

import (
    "fmt"
)

func main() {
    s := make([]int, 0, 3)
    for i := 1; i <= 15; i++ {
        s = append(s, i)
        fmt.Println(len(s), cap(s))
    }
    fmt.Println(s[10])
}
```

슬라이스 복사

Go의 내장함수 copy()를 이용하면 슬라이스를 복사할 수 있다. copy() 함수는 두 개의 파라미터를
받는데, 첫번째 파라미터는 복사본을 받을 슬라이스이고, 두번째 파라미터는 복사의 대상이 되는
원본 슬라이스이다. 

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1, 2, 3, 4, 5}
    t := make([]int, 3)
    n := copy(t, s[1:4])
    fmt.Println(t[2])
    fmt.Println(n)
}
```

슬라이스 비교

Go에서 슬라이스는 내부적으로 배열을 가리키는 포인터이므로, 슬라이스를 비교하는 경우에는
배열의 내용이 아니라 배열의 포인터를 비교하는 것이다. 

```go

package main

import (
    "fmt"
)

func main() {
    s1 := []int{0, 1, 2, 3, 4, 5}
    s2 := []int{0, 1, 2, 3, 4, 5}
    fmt.Println(s1[2] == s2[2])
    fmt.Println(s1[2:4] == s2[2:4])
}
```

슬라이스는 배열과 달리 내부적으로 포인터, 길이, 용량을 갖고 있으며, 이들을 모두 비교해야
두 슬라이스가 같은지를 비교할 수 있다. 

```go

package main

import (
    "fmt"
)

func main() {
    s1 := []int{0, 1, 2, 3, 4, 5}
    s2 := []int{0, 1, 2, 3, 4, 5}
    fmt.Println(s1[2] == s2[2])
    fmt.Println(s1[2:4] == s2[2:4])
    fmt.Println(s1[2:4] == s2[2:5])
    fmt.Println(s1 == nil)
}
```

슬라이스의 요소 삭제

Go 슬라이스에서 특정 인덱스의 요소를 삭제하려면 Go의 내장함수 append()와 슬라이스의 부분 슬라이스
기능을 사용하면 된다. 

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1, 2, 3, 4, 5}
    s = append(s[:2], s[3:]...)
    fmt.Println(s[2])
}
```

위 예제에서는 슬라이스의 2번째 요소를 삭제하고 있다. 슬라이스의 2번째 요소를 삭제하기 위해서는
append() 함수의 첫번째 파라미터로 슬라이스의 처음부터 삭제할 요소의 바로 앞까지의 부분 슬라이스를
지정하고, 두번째 파라미터로 삭제할 요소의 바로 다음부터 마지막 요소까지의 부분 슬라이스를 지정한다.
그리고 두번째 파라미터 뒤에 ... 을 붙여서 가변 파라미터임을 알려준다.

슬라이스의 요소 중에서 특정 조건을 만족하는 요소를 삭제하려면 다음과 같이 하면 된다. 

```go

package main

import (
    "fmt"
)

func main() {
    s := []int{0, 1, 2, 3, 4, 5}
    s = remove(s, 2)
    fmt.Println(s[2])
}

func remove(slice []int, s int) []int {
    return append(slice[:s], slice[s+1:]...)
}
```

위 예제에서는 슬라이스의 2번째 요소를 삭제하고 있다. 슬라이스의 2번째 요소를 삭제하기 위해서는
append() 함수의 첫번째 파라미터로 슬라이스의 처음부터 삭제할 요소의 바로 앞까지의 부분 슬라이스를
지정하고, 두번째 파라미터로 삭제할 요소의 바로 다음부터 마지막 요소까지의 부분 슬라이스를 지정한다.
그리고 두번째 파라미터 뒤에 ... 을 붙여서 가변 파라미터임을 알려준다.







































